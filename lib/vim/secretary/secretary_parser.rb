# Autogenerated from a Treetop grammar. Edits may be lost.


module Secretary
  include Treetop::Runtime

  def root
    @root ||= :secretary
  end

  module Secretary0
    def configs
      elements[0]
    end

    def config_finisher
      elements[1]
    end
  end

  module Secretary1
    def configuration
      elements[0]
    end

    def punches
      elements[2]
    end
  end

  module Secretary2
    def configs
      configuration.configs.elements
    end
  end

  def _nt_secretary
    start_index = index
    if node_cache[:secretary].has_key?(index)
      cached = node_cache[:secretary][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i2, s2 = index, []
    s3, i3 = [], index
    loop do
      r4 = _nt_config
      if r4
        s3 << r4
      else
        break
      end
    end
    r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
    s2 << r3
    if r3
      r5 = _nt_config_finisher
      s2 << r5
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(Secretary0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      s6, i6 = [], index
      loop do
        r7 = _nt_line_separator
        if r7
          s6 << r7
        else
          break
        end
      end
      r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
      s0 << r6
      if r6
        s8, i8 = [], index
        loop do
          r9 = _nt_punch
          if r9
            s8 << r9
          else
            break
          end
        end
        r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
        s0 << r8
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Secretary1)
      r0.extend(Secretary2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:secretary][start_index] = r0

    r0
  end

  module Config0
    def whitespace
      elements[0]
    end

    def anything
      elements[1]
    end
  end

  module Config1
    def indentation
      elements[1]
    end

    def key
      elements[2]
    end

    def value
      elements[4]
    end

    def line_separator
      elements[5]
    end
  end

  module Config2
    def as_yaml
      "#{indentation.text_value[1..-1]}#{key.text_value}: #{value.text_value.strip}"
    end
  end

  module Config3
    def line_separator
      elements[1]
    end
  end

  module Config4
    def as_yaml
      ""
    end
  end

  def _nt_config
    start_index = index
    if node_cache[:config].has_key?(index)
      cached = node_cache[:config][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    if has_terminal?("#", false, index)
      r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("#")
      r2 = nil
    end
    s1 << r2
    if r2
      r3 = _nt_whitespace
      s1 << r3
      if r3
        r4 = _nt_word
        s1 << r4
        if r4
          if has_terminal?(":", false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(":")
            r5 = nil
          end
          s1 << r5
          if r5
            i7, s7 = index, []
            r8 = _nt_whitespace
            s7 << r8
            if r8
              r9 = _nt_anything
              s7 << r9
            end
            if s7.last
              r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
              r7.extend(Config0)
            else
              @index = i7
              r7 = nil
            end
            if r7
              r6 = r7
            else
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s1 << r6
            if r6
              r10 = _nt_line_separator
              s1 << r10
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
      r1.extend(Config1)
      r1.extend(Config2)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i11, s11 = index, []
      if has_terminal?("#", false, index)
        r12 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("#")
        r12 = nil
      end
      s11 << r12
      if r12
        r13 = _nt_line_separator
        s11 << r13
      end
      if s11.last
        r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
        r11.extend(Config3)
        r11.extend(Config4)
      else
        @index = i11
        r11 = nil
      end
      if r11
        r0 = r11
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:config][start_index] = r0

    r0
  end

  module ConfigFinisher0
    def line_separator
      elements[1]
    end
  end

  def _nt_config_finisher
    start_index = index
    if node_cache[:config_finisher].has_key?(index)
      cached = node_cache[:config_finisher][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("# ---", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("# ---")
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_line_separator
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(ConfigFinisher0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:config_finisher][start_index] = r0

    r0
  end

  module Punch0
    def line_separator
      elements[0]
    end

    def comments
      elements[1]
    end
  end

  module Punch1
    def datetime
      elements[0]
    end

    def whitespace1
      elements[1]
    end

    def name
      elements[3]
    end

    def tags
      elements[4]
    end

    def whitespace2
      elements[6]
    end

    def whitespace3
      elements[8]
    end

    def description
      elements[9]
    end

    def comment_block
      elements[11]
    end
  end

  module Punch2
    def to_h
      data = {}
      data[:date] = datetime.text_value
      data[:name] = name.text_value
      data[:tags] = (tags.empty? ? [] : tags.to_a)
      data[:description] = description.text_value
      data[:comments] = (comment_block.respond_to?(:comments) ? comment_block.comments.to_s : '')
      data
    end
  end

  def _nt_punch
    start_index = index
    if node_cache[:punch].has_key?(index)
      cached = node_cache[:punch][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_datetime
    s0 << r1
    if r1
      r2 = _nt_whitespace
      s0 << r2
      if r2
        if has_terminal?("[", false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure("[")
          r3 = nil
        end
        s0 << r3
        if r3
          r5 = _nt_words
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
          if r4
            r7 = _nt_tag_list
            if r7
              r6 = r7
            else
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r6
            if r6
              if has_terminal?("]", false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 1))
                @index += 1
              else
                terminal_parse_failure("]")
                r8 = nil
              end
              s0 << r8
              if r8
                r9 = _nt_whitespace
                s0 << r9
                if r9
                  if has_terminal?("-", false, index)
                    r10 = instantiate_node(SyntaxNode,input, index...(index + 1))
                    @index += 1
                  else
                    terminal_parse_failure("-")
                    r10 = nil
                  end
                  s0 << r10
                  if r10
                    r11 = _nt_whitespace
                    s0 << r11
                    if r11
                      r12 = _nt_words
                      s0 << r12
                      if r12
                        r14 = _nt_line_separator
                        if r14
                          r13 = r14
                        else
                          r13 = instantiate_node(SyntaxNode,input, index...index)
                        end
                        s0 << r13
                        if r13
                          i16, s16 = index, []
                          r17 = _nt_line_separator
                          s16 << r17
                          if r17
                            r18 = _nt_comments
                            s16 << r18
                          end
                          if s16.last
                            r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
                            r16.extend(Punch0)
                          else
                            @index = i16
                            r16 = nil
                          end
                          if r16
                            r15 = r16
                          else
                            r15 = instantiate_node(SyntaxNode,input, index...index)
                          end
                          s0 << r15
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Punch1)
      r0.extend(Punch2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:punch][start_index] = r0

    r0
  end

  module Comments0
    def anything
      elements[0]
    end

  end

  module Comments1
    def comment
      elements[1]
    end
  end

  module Comments2
    def block
      elements[0]
    end
  end

  module Comments3
    def to_s
      block.elements.map {|line| line.comment.text_value}.join
    end
  end

  def _nt_comments
    start_index = index
    if node_cache[:comments].has_key?(index)
      cached = node_cache[:comments][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      s3, i3 = [], index
      loop do
        r4 = _nt_space
        if r4
          s3 << r4
        else
          break
        end
      end
      if s3.size < 2
        @index = i3
        r3 = nil
      else
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      end
      s2 << r3
      if r3
        i5, s5 = index, []
        r6 = _nt_anything
        s5 << r6
        if r6
          s7, i7 = [], index
          loop do
            r8 = _nt_line_separator
            if r8
              s7 << r8
            else
              break
            end
          end
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          s5 << r7
        end
        if s5.last
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          r5.extend(Comments0)
        else
          @index = i5
          r5 = nil
        end
        s2 << r5
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Comments1)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Comments2)
      r0.extend(Comments3)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:comments][start_index] = r0

    r0
  end

  module Datetime0
    def chars
      elements[0]
    end
  end

  module Datetime1
    def to_s
      text_value
    end
  end

  def _nt_datetime
    start_index = index
    if node_cache[:datetime].has_key?(index)
      cached = node_cache[:datetime][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      if has_terminal?('\G[0-9\\.,\\-T:]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Datetime0)
      r0.extend(Datetime1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:datetime][start_index] = r0

    r0
  end

  def _nt_anything
    start_index = index
    if node_cache[:anything].has_key?(index)
      cached = node_cache[:anything][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[a-zA-Z0-9\\_\\\'!\\.,\\-#`\\*: \\t\\[\\]\\/\\\\\\?\\"\\\'%\\(\\)\\=\\{\\}|\\&]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:anything][start_index] = r0

    r0
  end

  module Words0
    def word
      elements[0]
    end

  end

  module Words1
    def main_words
      elements[0]
    end

    def last_word
      elements[1]
    end
  end

  module Words2
    def to_s
      main_words + Array(last_word)
    end
  end

  def _nt_words
    start_index = index
    if node_cache[:words].has_key?(index)
      cached = node_cache[:words][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      i2, s2 = index, []
      r3 = _nt_word
      s2 << r3
      if r3
        r5 = _nt_whitespace
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(Words0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    end
    s0 << r1
    if r1
      r7 = _nt_word
      if r7
        r6 = r7
      else
        r6 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r6
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Words1)
      r0.extend(Words2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:words][start_index] = r0

    r0
  end

  def _nt_word
    start_index = index
    if node_cache[:word].has_key?(index)
      cached = node_cache[:word][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?('\G[a-zA-Z0-9\\_\\\'!\\.,\\-#`\\*]', true, index)
        r1 = true
        @index += 1
      else
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:word][start_index] = r0

    r0
  end

  module TagList0
    def tag
      elements[1]
    end
  end

  module TagList1
    def first_tag
      elements[1]
    end

    def rest_tags
      elements[2]
    end
  end

  module TagList2
    def to_a
      Array(first_tag.text_value) + rest_tags
    end

    def rest_tags
      super.elements.map {|colon_and_tag| colon_and_tag.tag.text_value }
    end
  end

  def _nt_tag_list
    start_index = index
    if node_cache[:tag_list].has_key?(index)
      cached = node_cache[:tag_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?(":", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(":")
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_words
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          i4, s4 = index, []
          if has_terminal?(":", false, index)
            r5 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(":")
            r5 = nil
          end
          s4 << r5
          if r5
            r6 = _nt_words
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(TagList0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(TagList1)
      r0.extend(TagList2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:tag_list][start_index] = r0

    r0
  end

  module ProjectName0
    def to_s
      words.join
    end
  end

  def _nt_project_name
    start_index = index
    if node_cache[:project_name].has_key?(index)
      cached = node_cache[:project_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_words
    r0.extend(ProjectName0)

    node_cache[:project_name][start_index] = r0

    r0
  end

  module Description0
    def to_s
      words.join
    end
  end

  def _nt_description
    start_index = index
    if node_cache[:description].has_key?(index)
      cached = node_cache[:description][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_words
    r0.extend(Description0)

    node_cache[:description][start_index] = r0

    r0
  end

  def _nt_whitespace
    start_index = index
    if node_cache[:whitespace].has_key?(index)
      cached = node_cache[:whitespace][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_space
      if r2
        r1 = r2
      else
        r3 = _nt_tab
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:whitespace][start_index] = r0

    r0
  end

  def _nt_space
    start_index = index
    if node_cache[:space].has_key?(index)
      cached = node_cache[:space][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(' ', false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(' ')
      r0 = nil
    end

    node_cache[:space][start_index] = r0

    r0
  end

  def _nt_tab
    start_index = index
    if node_cache[:tab].has_key?(index)
      cached = node_cache[:tab][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[\\t]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:tab][start_index] = r0

    r0
  end

  def _nt_line_separator
    start_index = index
    if node_cache[:line_separator].has_key?(index)
      cached = node_cache[:line_separator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[\\n\\r]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:line_separator][start_index] = r0

    r0
  end

  def _nt_line_separators
    start_index = index
    if node_cache[:line_separators].has_key?(index)
      cached = node_cache[:line_separators][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_line_separator
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.size < 2
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:line_separators][start_index] = r0

    r0
  end

end

class SecretaryParser < Treetop::Runtime::CompiledParser
  include Secretary
end

